<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="测试">
<meta property="og:type" content="website">
<meta property="og:title" content="熊小宇的技术博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="熊小宇的技术博客">
<meta property="og:description" content="测试">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="熊小宇的技术博客">
<meta name="twitter:description" content="测试">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>

  <title> 熊小宇的技术博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">熊小宇的技术博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Since 2016</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/09/30/深入NXP低功耗蓝牙SDK开发系列-编程框架剖析/" itemprop="url">
                  深入NXP低功耗蓝牙SDK开发系列 - 编程框架剖析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-09-30T10:10:39+08:00" content="2018-09-30">
              2018-09-30
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>很久没有更新技术博客了。最近一年都在做低功耗蓝牙和物联网等相关的事情，想把一些经验和心得写成博客分享出来，也算对自己工作的一种总结。开一个系列讲解NXP的低功耗蓝牙SDK开发的方方面面，目前NXP官方仅有一个英文版的《BLE Application Developer Guide》介绍SDK的使用，对于国内开发者来说不太友好。希望这个系列文章能作为官方文档的补充，帮助到正在使用和将要使用NXP蓝牙的芯片的朋友们。</p>
<p>weil家深入这个通用的低功耗蓝牙SDK与协议栈，迅速掌握NXP低功耗蓝牙的开发。假设用户已经具备了基本的BLE概念，如Profile、GAP、GATT、HCI、LL等各个层次的职责，广播与连接的行为，基于GATT数据传输的方式等。如果读者对这个概念还不熟悉，可以阅读《Getting Started with Bluetooth Low Energy》一书的第1至3章共75页内容，利用业余时间在2-3天内可以轻松完成。</p>
<h1 id="NXP-BLE-SoC概况"><a href="#NXP-BLE-SoC概况" class="headerlink" title="NXP BLE SoC概况"></a>NXP BLE SoC概况</h1><p>目前NXP面向物联网和可穿戴设备数据传输应用的BLE SoC芯片要有QN和KW两大系列（型号特点见下表），除了QN902x使用原Quintic自带的协议栈SDK外，其他几个型号都采用了NXP MCUXpresso SDK和NXP自研的Bluetooth协议栈，呈现给用户的编程接口完全一致。无论是开发超低功耗的QN9080，支持Zigbee/Thread/BLE多模的KW41，还是面向汽车应用的KW36，对固件工程师来说，掌握了一款芯片的开发，拿下其他的也就是轻而易举之事。</p>
<table>
<thead>
<tr>
<th>型号</th>
<th>协议版本</th>
<th>内核频率</th>
<th>存储器资源</th>
<th>特色</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>QN902x</strong></td>
<td>BLE 4.2</td>
<td>Cortex-M0 @32MHz</td>
<td>128KB Flash / 64KB RAM / 128KB ROM</td>
<td>低成本</td>
</tr>
<tr>
<td><strong>QN908x</strong></td>
<td>BLE 5.0</td>
<td>Cortex-M4F @32MHz</td>
<td>512KB Flash / 128KB RAM</td>
<td>超低功耗</td>
</tr>
<tr>
<td><strong>KW41</strong></td>
<td>BLE 4.2</td>
<td>Cortex-M0+ @48MHz</td>
<td>512KB Flash / 128KB RAM</td>
<td>多模多协议</td>
</tr>
<tr>
<td><strong>KW36</strong></td>
<td>BLE 5.0</td>
<td>Cortex-M0+ @48MHz</td>
<td>512KB Flash / 64KB RAM</td>
<td>汽车网络</td>
</tr>
<tr>
<td><strong>K32W</strong></td>
<td>BLE 5.0</td>
<td>Cortex-M4F &amp; Cortex-M0+ @72MHz</td>
<td>1.25MB Flash / 384KB RAM</td>
<td>单芯片高集成度</td>
</tr>
</tbody>
</table>
<h1 id="MCUXpresso-SDK与NXP-BLE协议栈"><a href="#MCUXpresso-SDK与NXP-BLE协议栈" class="headerlink" title="MCUXpresso SDK与NXP BLE协议栈"></a>MCUXpresso SDK与NXP BLE协议栈</h1><p>MCUXpresso SDK是NXP面向MCU市场推出的一套完整的软件开发套件，支持Kinetis, LPC, i.MX RT等通用微控制器以及QN和JN系列的无线连接微控制器。一个SDK包内包含了芯片硬件抽象层，外设驱动库，多个中间件库（根据芯片功能的不同包含不同的中间件，比如带Ethernet外设的MCU则会有lwip网络协议栈中间件），以及丰富的示例代码。</p>
<p>对于低功耗蓝牙MCU，它的BLE协议栈作为MCUXpresso SDK的一个中间件而存在。在用户解压缩SDK包后，在./middleware/wireless/bluetooth_x.y.z下可以找到协议栈的代码和库文件。低功耗蓝牙应用将包含这个目录下的文件，以使用协议栈提供的API和服务。所有低功耗蓝牙的示例代码可以再./boards/<specific board="">/wireless_examples/bluetooth目录下找到。同时，低功耗蓝牙应用与通用MCU SDK还有一点差异，它需要一些额外的通用组件作为支撑，如OS环境抽象、非易失存储、队列管理，低功耗管理等，因此多引入了一个connectivity framework的中间件层。在./middleware/wireless/framework_x.y.z下可以找到framework包含的所有功能模块源代码。下图展示了SDK的文件结构中与低功耗蓝牙相关的目录。</specific></p>
<p><img src="https://upload-images.jianshu.io/upload_images/3046528-12d71b1b39f7c434.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MCUXpresso SDK文件目录组织"></p>
<blockquote>
<p>如果基于MCUXpresso IDE开发，通常会导出某个示例工程到workspace目录下，被导出的工程与解压缩后的SDK的layout稍有不同，它仅包含了该示例代码所需的驱动和中间件，并以一个平铺的方式组织文件夹，但文件夹下的内容并无区别。</p>
</blockquote>
<h1 id="NXP-BLE-SDK系统架构"><a href="#NXP-BLE-SDK系统架构" class="headerlink" title="NXP BLE SDK系统架构"></a>NXP BLE SDK系统架构</h1><p>NXP提供了一套完整的BLE协议栈和编程框架，并已通过了Bluetooth Core Spec 5.0的认证。用户第一次开发自己的应用时，应当先大致了解整个系统的组成，知道每个部分的职责，分别有哪些文件。有了一些基础，再通过查询API文档，很快便能掌握BLE应用开发。下图为BLE SDK总体的框架图，图中使用了几种不同的颜色来区分：</p>
<ul>
<li>应用（灰）</li>
<li>低功耗蓝牙服务框架（黄）</li>
<li>Connectivtiy Framework（绿）</li>
<li>BLE协议栈（蓝）</li>
<li>通用SDK（白）</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/3046528-235744c5fc0a161b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="NXP BLE SDK系统架构"></p>
<h2 id="OSA"><a href="#OSA" class="headerlink" title="OSA"></a>OSA</h2><p>OSA属于Connectivity Framework，单独介绍它是因为OSA服务于整个SDK和协议栈，并且也是系统复位后的入口。整个蓝牙协议栈和SDK的设计使用了RTOS下才有的多任务，消息和事件等服务。为了减少代码大小和栈的内存，适配一些资源紧张的SoC，在设计时才引入了OSA。</p>
<p>OSA提供一套接口封装，底层可以使用FreeRTOS或者Bare Metal前后台两种实现。如果底层为FreeRTOS，OSA只是简单的将FreeRTOS API转换为OSA API。如果底层底层为Bare Metal系统，OSA则内部实现了一套多任务、信号量、事件等RTOS API的模拟实现，当用户调用OSA_Start启动多任务调度环境时，实际上是陷入了一个while(1)的循环，在这个循环中会不断的检查任务队列的状态并选择优先级最高的任务来运行，这些任务之间无法抢占，因此每个任务的设计需要额外小心，占用CPU的时间最好不要超过2ms，以确保处理BLE事件的任务能及时得到调度。在编写OSA的任务代码时，有几个不同与一般RTOS的地方需要注意。</p>
<ul>
<li>任务体while(1)循环的最后需要加上一个条件判断，如果是gUseRtos_c==0，则直接跳出循环，相当于每次任务只执行一次。</li>
<li>任务体while(1)循环之前的初始化工作需要特殊化处理，定义一个静态或者全局变量initailized的，并对它进行测试，确保在当OSA运行在Bare Metal配置时，这些初始化代码仅会运行一次。</li>
<li>OSA_EventWait, OSA_SemphoreWait, OSA_MutexLock等函数在OSA的FreeRTOS实现时会阻塞任务，而在Bare Metal实现中，调用这些API不会阻塞，而是通过内部一个状态机来检测资源，如果资源目前是不可获得状态，则直接返回。</li>
<li>OSA_TimeDelay函数在BM实现时是不会切换到其他任务运行的，而是在原地等待直到超时。</li>
</ul>
<p>OSA的源码可以在实现./middleware/wireless/framework_x.y.z/OSAbstraction下找到，如感兴趣可以深入研读。</p>
<blockquote>
<p>SDK提供的每一份BLE示例代码中都提供了freertos和bm两个工程。</p>
</blockquote>
<h2 id="Connectivity-Framework"><a href="#Connectivity-Framework" class="headerlink" title="Connectivity Framework"></a>Connectivity Framework</h2><p>Connectivity Framework包含了众多的子模块，服务于应用和BLE协议栈。本系列文章将会抽取其中几个比较重要的几个子模块作为单独的文章来分析。本文希望先给读者一个总体概念，通过表格列出了各个模块的职责和必要性。标注为“必要”的模块如果缺失，最后整个BLE工程构建将会失败，说明该模块已被协议栈或者其他的代码引用了。标注为“非必要”的模块目的是服务应用层，如果用户的应用不需要这个功能，则可以移除。</p>
<table>
<thead>
<tr>
<th>子模块</th>
<th>职责</th>
<th>必要性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>FunctionLib</strong></td>
<td>memcpy等标准函数的封装</td>
<td>必要</td>
<td>通过头文件配置选择私有实现或直接使用C库</td>
</tr>
<tr>
<td><strong>List</strong></td>
<td>通用双向链表实现</td>
<td>必要</td>
<td>List是MemManager和Messaging的基础</td>
</tr>
<tr>
<td><strong>MemManager</strong></td>
<td>基于块的内存分配</td>
<td>必要</td>
<td>协议栈所需的动态内存都从这里分配</td>
</tr>
<tr>
<td><strong>Messaging</strong></td>
<td>消息队列服务</td>
<td>必要</td>
<td>不具备任务同步功能，需配合OSA Event使用</td>
</tr>
<tr>
<td><strong>OSAbstraction</strong></td>
<td>提供操作系统服务抽象</td>
<td>必要</td>
<td>整个系统调度都依赖于OSA</td>
</tr>
<tr>
<td><strong>TimersManager</strong></td>
<td>提供软定时服务</td>
<td>必要</td>
<td>协议栈超时机制需要使用到</td>
</tr>
<tr>
<td><strong>SecLib</strong></td>
<td>封装SMP加密操作</td>
<td>必要</td>
<td>部分芯片可以选择使用硬件加密加速引擎</td>
</tr>
<tr>
<td><strong>LowPower</strong></td>
<td>实现低功耗管理</td>
<td>非必要</td>
<td>仅当系统需要使用低功耗时用到</td>
</tr>
<tr>
<td><strong>OtaSupport</strong></td>
<td>提供OTA服务</td>
<td>非必要</td>
<td>仅包含OTA的应用需要用到</td>
</tr>
<tr>
<td><strong>SerialsManager</strong></td>
<td>提供不同串行通讯链路层的封装</td>
<td>非必要</td>
<td>当配置协议栈为DTM模式或Host Only模式时需要）</td>
</tr>
<tr>
<td><strong>Flash</strong></td>
<td>对不同芯片内部和外部Flash操作的封装</td>
<td>非必要</td>
<td>当包括NVM模块时为必要</td>
</tr>
<tr>
<td><strong>NVM</strong></td>
<td>在Flash上提供一套非易失存储机制</td>
<td>非必要</td>
<td>仅当系统需要用到Bonding时才为必要</td>
</tr>
<tr>
<td><strong>MWS</strong></td>
<td>多协议共存协议</td>
<td>非必要</td>
<td>当需要与外部WLAN芯片配</td>
</tr>
<tr>
<td><strong>Shell</strong></td>
<td>提供控制台交互和格式化打印功能</td>
<td>非必要</td>
<td>服务于应用程序</td>
</tr>
<tr>
<td><strong>GPIO/LED/Keyboard</strong></td>
<td>提供简单输入输出能力</td>
<td>非必要</td>
<td>服务于应用程序</td>
</tr>
<tr>
<td><strong>Reset/Panic/RNG</strong></td>
<td>对系统各个功能的简单封装</td>
<td>非必要</td>
<td>服务于应用程序</td>
</tr>
</tbody>
</table>
<h2 id="BLE协议栈"><a href="#BLE协议栈" class="headerlink" title="BLE协议栈"></a>BLE协议栈</h2><p>BLE协议栈以闭源库的形式提供，分为Host和Controller两部分。下图描述了组成Stack的主要文件和相互之间的依赖关系。<img src="https://upload-images.jianshu.io/upload_images/3046528-6ee1bc76b46d5359.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>Controller Stack负责与硬件和时序相关的蓝牙链路层处理，它通过HCI接口与Host Stack进行协同工作完成BLE数据交互。由于使用BLE SDK时几乎不需要直接与Controller Stack打交道，我们知道它的存在即可。</p>
<p>Host Stack是一个与硬件无关的C库，它通过HCI接口向Controller Stack发送命令和接收消息，负责完成Bluetooth Core Spec中的L2CAP, ATT, SM, GATT, GAP等多个层次职责。Host Stack通过一组头文件暴露出协议栈各个层的API和回调事件接口，理解Host Stack提供的服务和数据结构对于掌握BLE SDK开发至关重要。本系列专题将以独立文章分享各个部分服务的具体应用，这里先将协议栈的两类主要接口介绍给大家。</p>
<ol>
<li><p>API<br>API即应用程序编程接口，是外部应用主动向协议栈发起请求的入口。协议栈所提供的绝大部分API都是异步的，利用Messaging消息队列向协议栈的Host任务发送一条后便返回。实际的处理是在Host任务中完成，再通过某个注册的callback回调函数来反馈执行的结果。</p>
</li>
<li><p>Callback注册回调函数<br>Callback注册回调函数是由应用程序提供的一个钩子函数，在协议栈内部处理中如果有需要通知到用户层事件发生或者数据变化时，将调用注册的钩子函数通知应用程序做出响应动作。</p>
</li>
</ol>
<p>下面一段示例代码演示了Gap_Connect()和Gap_Disconnect()两个异步API的行为和他们所触发的callback回调函数后对应事件的响应。通过这段代码可以大致了解应用代码如何与协议栈进行交互。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// 1. initiate API to request and connection and register a callback</div><div class="line">bleResult_t rt;</div><div class="line">rt = Gap_Connect(&amp;gConnReqParams, Gap_ConnectionCallback);</div><div class="line">if (rt != gBleSuccess_c) &#123;</div><div class="line">    printf(&quot;Gap_Connect API fail, reason = %d\r\n&quot;, rt);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// when PC(R15) arrives here, the connection may NOT be setup</div><div class="line">... </div><div class="line"></div><div class="line">// 2. initiate API to request a disconnection action.</div><div class="line">rt = Gap_Disconnect(peerDeviceId);</div><div class="line">if (rt != gBleSuccess_c) &#123;</div><div class="line">    printf(&quot;Gap_Disconnect fail, reason = %d\r\n&quot;, rt);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// when PC(R15) arrives here, the connection may NOT be disconnected</div><div class="line">... </div><div class="line"></div><div class="line">// 3. Event will be triggered when connection and disconnection happens</div><div class="line">void Gap_ConnectionCallback(deviceId_t peerDeviceId, gapConnectionEvent_t* pConnectionEvent)</div><div class="line">&#123;</div><div class="line">    switch (pConnectionEvent-&gt;eventType)</div><div class="line">    &#123;</div><div class="line">        case gConnEvtConnected_c:</div><div class="line">            // async event to notify that link is connected</div><div class="line">            printf(&quot;Connected to device (%d)\r\n&quot;, peerDeviceId);</div><div class="line">            break;</div><div class="line">           </div><div class="line">        case gConnEvtDisconnected_c:</div><div class="line">             // async event to notify that link is disconnected</div><div class="line">            printf(&quot;Disconnected to device (%d)\r\n&quot;, peerDeviceId);</div><div class="line">            break;</div><div class="line">            ...</div></pre></td></tr></table></figure>
<h2 id="低功耗蓝牙服务框架"><a href="#低功耗蓝牙服务框架" class="headerlink" title="低功耗蓝牙服务框架"></a>低功耗蓝牙服务框架</h2><p>低功耗蓝牙服务框架这个名称是笔者取给SDK中非协议栈部分的蓝牙代码取一个名字，涉及内容主要包括有HCI、FSCI、Profiles、Connection Manager, Service Discovery, App Thread, BLE Initialization, Stack Runtime Environment等几个部分，顾名思义是这些代码都是为实现BLE应用而服务的，目的是简化用户开发的难度。</p>
<ul>
<li><strong>Stack Runtime Environment</strong> </li>
</ul>
<p>上一小节介绍的Host和Controller协议栈库提供的是一组可链接的符号，需要外部创建任务以提供运行时环境和创建必要的队列和事件资源，这就是Stack Runtime Environment的职责。协议栈提的了两个任务处理函数Host_TaskHandler()和Controller_TaskHandler()，分别在创建的Host_task和Controller_task里调用。另外任务处理函数还需要用到队列和事件资源，用户任务与Host_task交互、以及Host_task与Controller_task的交互都依赖于他们。下表说明了所创建资源的用途。</p>
<table>
<thead>
<tr>
<th>资源</th>
<th>类别</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>gApp2Host_TaskQueue</strong></td>
<td>消息队列</td>
<td>用户任务调用Host Stack API时，向这个队列插入一个请求</td>
</tr>
<tr>
<td><strong>gHci2Host_TaskQueue</strong></td>
<td>消息队列</td>
<td>Controller Taskdan产生HCI事件时，向这个队列插入一个请求</td>
</tr>
<tr>
<td><strong>gHost_TaskEvent</strong></td>
<td>OSA事件</td>
<td>用于通知Host Stack队列中有新的消息插入</td>
</tr>
<tr>
<td><strong>mControllerTaskEvent</strong></td>
<td>OSA事件</td>
<td>Host Task向Controller Task发送HCI命令时或中断向Controller Task请求服务</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>App Thread</strong></li>
</ul>
<p>App Thread是在系统启动后由OSA创建的第一个任务，它在完成BLE系统初始化后创建了一个应用后台，主要目的是服务Host stack触发的各类callback回调事件。通过Host_stack提供的Registeration API注册的回调函数被调用的上下文都是前面介绍的Host task里，如果在这些callback做一些耗时较长的用户动作（比如上面的printf打印输出），Host task其他部分会得不到响应，从而影响BLE协议交互。因此很有必要将这些callback回调事件的处理放到一个相对低优先级任务中，这个任务就是App Thread。首先Applmain.c中对Host stack提供的回调函数接口都做了实现，这些实现并不作实际处理，而是转发一个消息到App Thread。App Thread一直处于等待事件的状态，收到事件后再分发到各个自定义的callback中作相应处理。App Thread同时还可以通过等待另外一个队列来接收其他任务发送的Application消息并处理，以方便用户实现类似于协议栈的异步处理机制。下表列出了App Thread的队列和时间资源以及他们的用途。</p>
<table>
<thead>
<tr>
<th>资源</th>
<th>类别</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>mHostAppInputQueue</strong></td>
<td>消息队列</td>
<td>Host Stack产生的callback里将向这个队列插入一个请求</td>
</tr>
<tr>
<td><strong>mAppCbInputQueue</strong></td>
<td>消息队列</td>
<td>App Thread本身或者其他用户任务都可以向这个队列插入一个请求</td>
</tr>
<tr>
<td><strong>mAppEvent</strong></td>
<td>OSA事件</td>
<td>用于通知App Thread有队列里有新的消息插入</td>
</tr>
</tbody>
</table>
<p>下面代码段以App_Connect为例来展示了代码是如何通过App Thread来处理Host stack回调函数的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// User call App_Connect, instead of Gap_Connect</div><div class="line">bleResult_t App_Connect(gapConnectionRequestParameters_t*   pParameters,</div><div class="line">                        gapConnectionCallback_t             connCallback)</div><div class="line">&#123;</div><div class="line">    pfConnCallback = connCallback;</div><div class="line">    return Gap_Connect(pParameters, App_ConnectionCallback);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Simplified App_ConnectionCallback, the function insert a message and notify App Thread</div><div class="line">void App_ConnectionCallback (deviceId_t peerDeviceId, gapConnectionEvent_t* pConnectionEvent)</div><div class="line">&#123;</div><div class="line">    appMsgFromHost_t *pMsgIn = NULL;   </div><div class="line">    uint8_t msgLen = GetRelAddr(appMsgFromHost_t, msgData) + sizeof(connectionMsg_t);</div><div class="line">    </div><div class="line">    pMsgIn = MSG_Alloc(msgLen);</div><div class="line">    // use Applmain defined message type</div><div class="line">    pMsgIn-&gt;msgType = gAppGapConnectionMsg_c; </div><div class="line">    pMsgIn-&gt;msgData.connMsg.deviceId = peerDeviceId;</div><div class="line"></div><div class="line">    FLib_MemCpy(&amp;pMsgIn-&gt;msgData.connMsg.connEvent, pConnectionEvent, sizeof(gapConnectionEvent_t));</div><div class="line">    MSG_Queue(&amp;mHostAppInputQueue, pMsgIn);</div><div class="line">    OSA_EventSet(mAppEvent, gAppEvtMsgFromHostStack_c);  </div><div class="line">&#125;</div><div class="line"></div><div class="line">// Pseduo code of App_Thread</div><div class="line">void App_Thread (uint32_t param)</div><div class="line">&#123;</div><div class="line">    while(1) &#123;</div><div class="line">        OSA_EventWait(mAppEvent, osaEventFlagsAll_c, FALSE, osaWaitForever_c , &amp;event);</div><div class="line"></div><div class="line">        if (event &amp; gAppEvtMsgFromHostStack_c) &#123;</div><div class="line">            while (MSG_Pending(&amp;mHostAppInputQueue))  &#123;</div><div class="line">                pMsgIn = MSG_DeQueue(&amp;mHostAppInputQueue);</div><div class="line">                // check msgType and dispatch callback handler</div><div class="line">                if (pMsg-&gt;msgType == gAppGapConnectionMsg_c) &#123;</div><div class="line">                    pfConnCallback(pMsg-&gt;msgData.connMsg.deviceId, &amp;pMsg-&gt;msgData.connMsg.connEvent);</div><div class="line">                &#125; else if (pMsg-&gt;msgType == ...) &#123;</div></pre></td></tr></table></figure>
<p>通过下图可以全面的了解到App Thread, Host task和Controller task三者之间是如何完成交互的。掌握了这张图的消息交互流程，开发基于NXP BLE SDK的应用也就变的非常容易了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3046528-25f19bfac57e57a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ky"></p>
<ul>
<li><p><strong>HCI</strong><br>HCI是低功耗蓝牙Controller协议栈和Host协议栈之间的沟通桥梁，对于SoC，两个协议栈都运行在同一芯片上，这部分功能实际上是简单的函数调用。当BLE SDK被配置为只作为controller Only模式（用于DTM），或者Host Only模式（controller使用另外一颗芯片）时，HCI的就需要与通过SerialManager来完成与外界通讯。</p>
</li>
<li><p><strong>FSCI</strong><br>FSCI是<strong>F</strong>ramework <strong>S</strong>erial <strong>C</strong>ommunication <strong>I</strong>nterface的缩写，该模块定义了一套统一的接口将无线通讯微控制器（BLE，Thread，Zigbee）所提供的服务提供给另外一颗主处理器或者PC系统。对于BLE SoC而言，片上运行了完整的BLE Host和Controller协议栈，此时处于Network Processor网络处理器模式。外部处理器在只需要遵循FSCI协议便能控制SoC发起广播、建立连接和进行数据交换。</p>
</li>
<li><p><strong>Profiles</strong><br>在GATT之上，Bluetooth SIG定义了多个标准的GATT based Profile帮助应用层互联互通，同时每个厂家也会定义一些简单的私有Profile来实现raw数据传输、OTA等功能。由于所有的Callback回调事件处理都是在应用中完成的，Profile在NXP BLE SDK中职责比较简单，主要负责完成Profile数据到GATT数据库的操作转换。</p>
</li>
<li><p><strong>Conneciton Manager</strong> 与 <strong>Service Discovery</strong><br>连接建立和服务发现是每个BLE应用都需要经历的过程，BLE SDK将这部分通用的代码从应用层分离了出来，形成两对独立的.c/.h文件ble_conn_manager.c/h和ble_service_discovery.c/h。这样减少了应用层重复的代码，提高代码可维护性。这两个部分服务的功能在后面介绍蓝牙SDK具体编程的文章中都会有所涉及。</p>
</li>
<li><p><strong>GATT Database</strong><br>通过一套宏定义的方法，完成静态或者动态GATT数据库的建立。第一次看到gatt_db.h会很难以理解里面的特殊格式，但要是“照猫画虎”的增加自己的service或者characeteristic还是比较简单的，这就是它的神奇之处。写一篇文章专门讲解gatt_db模块到底是如何通过一系列的宏定义来成这个工作的。</p>
</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>BLE SDK的每个应用示例都包含了十分类似的应用层文件，下表简单描述了各个文件的职责。其中<user_app>.c/h是整个应用的核心。</user_app></p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>职责</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>app_config.c</strong></td>
<td>BLE广播参数、扫描参数、安全性相关的配置</td>
</tr>
<tr>
<td><strong>app_preinclude.h</strong></td>
<td>全局参数配置文件（其他文件不需要include此文件，在IDE里已配置）</td>
</tr>
<tr>
<td><strong>gatt_db.h</strong></td>
<td>GATT database描述文件</td>
</tr>
<tr>
<td><strong>gatt_uuid128.h</strong></td>
<td>私有128位UUID描述文件</td>
</tr>
<tr>
<td><strong><user_app>.c/h</user_app></strong></td>
<td>应用示例代码，如heart_rate_sensor.c，广播发起、扫描，以及各种BLE协议栈事件的处理</td>
</tr>
</tbody>
</table>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文从零开始介绍NXP BLE SDK系统架构，逐步分析了各个子模块的功能。对于BLE协议栈和服务框两部分作了较为细致的讲解，以帮助大家了解自己编写的应用是如何与框架进行交互的。本文是《深入NXP低功耗蓝牙SDK开发系列》的第一篇，涵盖内容较广。如果您觉得其中某部分功能的介绍太过简单，不要心急，留言给我，后续会有多篇文章一步步教大家如何上手BLE SDK开发，敬请期待吧：）。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/06/树莓派3B+ Raspbian桌面分辨率设置/" itemprop="url">
                  树莓派3B+ Raspbian桌面分辨率设置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-02-06T16:11:24+08:00" content="2017-02-06">
              2017-02-06
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="查看支持分辨率"><a href="#查看支持分辨率" class="headerlink" title="查看支持分辨率"></a>查看支持分辨率</h1><p>第一次安装了Raspbian后启动系统会模式使用显示器“兼容模式”，这是一个VGA @ 60Hz的设置保证所有的HDMI连接到任何显示设备都能有显示。进入桌面后用户可以通过系统配置文件/boot/config.txt来修改分辨率</p>
<p>首先启动Shell输入命令查看系统所支持的模式：<br>如果用的是显示器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/opt/vc/bin/tvservice -m DMT</div></pre></td></tr></table></figure></p>
<p>如果接的是电视：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/opt/vc/bin/tvservice -m CEA</div></pre></td></tr></table></figure></p>
<p>在我的DELL显示器上给出的列表中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Group DMT has 11 modes:</div><div class="line">          mode 4: 640x480 @ 60Hz 4:3, clock:25MHz progressive</div><div class="line">          mode 6: 640x480 @ 75Hz 4:3, clock:31MHz progressive</div><div class="line">          ...</div><div class="line"> (prefer) mode 82: 1920x1080 @ 60Hz 16:9, clock:148MHz progressive</div><div class="line">          mode 83: 1600x900 @ 60Hz 16:9, clock:108MHz progressive</div></pre></td></tr></table></figure></p>
<h1 id="选择合适分辨率"><a href="#选择合适分辨率" class="headerlink" title="选择合适分辨率"></a>选择合适分辨率</h1><p>一般选择最优的模式，即1920x1080 @ 60Hz。<br>下面命令修改并确保参数是正确的，CTRL+O 回车保存，CTRL+X退出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo nano /boot/config.txt</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">#hdmi_safe=1  // 禁止safe模式</div><div class="line">hdmi_group=2  // 1=电视, 2=显示器</div><div class="line">hdmi_mode=82  // 1920x1080@60Hz</div><div class="line">...</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Reboot</div></pre></td></tr></table></figure>
<h1 id="作死"><a href="#作死" class="headerlink" title="作死"></a>作死</h1><p>手痒试一试选择不支持的分辨率（e.g. mode=3）…果然…黑屏了….</p>
<p><img src="http://oeti6csx6.bkt.clouddn.com/blog/20170206/172246962.png" alt=""></p>
<p>也不用担心，默认启动的时候按住SHIFT进入Recovery状态，Edit Config中也可以编辑/boot/config.txt文件，修改回正确数值即可。</p>
<p><img src="http://oeti6csx6.bkt.clouddn.com/blog/20170206/172319295.png" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/26/喝咖啡理解三层云服务IaaS-PaaS-SaaS/" itemprop="url">
                  喝咖啡理解三层云服务IaaS/PaaS/SaaS
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-12-26T18:41:43+08:00" content="2016-12-26">
              2016-12-26
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://oeti6csx6.bkt.clouddn.com/blog/20170206/184229507.jpg" alt=""></p>
<h1 id="思考三层云服务的合理比喻"><a href="#思考三层云服务的合理比喻" class="headerlink" title="思考三层云服务的合理比喻"></a>思考三层云服务的合理比喻</h1><p>在网上看到一些把三层云服务比喻成吃披萨，开养猪场等例子，相当生动形象。<a href="https://www.zhihu.com/question/21641778" target="_blank" rel="external">知乎: 谁能举个通俗易懂的例子告诉我IAAS，SAAS，PAAS的区别？</a> 但有一点似乎都被大家都忽略了，三层云服务所面对的客户是有所区别的。我觉得有必要把比喻打得更加贴切一些。写下自己的理解，从买一杯咖啡开始。</p>
<h1 id="SaaS：软件即服务-开个咖啡店"><a href="#SaaS：软件即服务-开个咖啡店" class="headerlink" title="SaaS：软件即服务 = 开个咖啡店"></a>SaaS：软件即服务 = 开个咖啡店</h1><blockquote>
<p>SaaS 是 <strong>S</strong>oftware <strong>a</strong>s <strong>a</strong> <strong>S</strong>ervice 的缩写</p>
</blockquote>
<p>在穿过海岸城广场去往地铁站的路上，一字排开的临街商铺前总热闹非凡。各式各样的门店来满足着消费者的生活需求：</p>
<ul>
<li>餐饮</li>
<li>文化</li>
<li>教育</li>
<li>电子产品</li>
<li>其他…</li>
</ul>
<p><strong>SaaS</strong>服务提供商跟这些商铺一样，也是云服务中与终端消费者日常接触的一层，来满足各种不同的应用需求。困了我会买一杯香浓的咖啡，不需要自己选咖啡豆、买咖啡机再翻出各种攻略来研究怎么煮一上壶。同样我有文件要存储共享我会使用云盘，而不是自己建个存储平台再搭个FTP什么的，为了可靠安全的存储我可能会选择一些大公司产品，比如iCloud Drive，所以付点钱也是值得的。</p>
<p>除了办公、存储、社交、视频这些面向个人消费者的<strong>SaaS</strong>云服务，还有很大一部分是面向企业的SaaS，如Saleforce, GoToMeeting等。如果把企业看做一个消费者，这之间没有什么实质差别。</p>
<h2 id="角色扮演："><a href="#角色扮演：" class="headerlink" title="角色扮演："></a>角色扮演：</h2><ul>
<li><strong>SaaS</strong> 提供商：咖啡店及各种商铺</li>
<li><strong>SaaS</strong> 消费者：普通消费者</li>
</ul>
<h1 id="PaaS：平台即服务-运营购物中心"><a href="#PaaS：平台即服务-运营购物中心" class="headerlink" title="PaaS：平台即服务 = 运营购物中心"></a>PaaS：平台即服务 = 运营购物中心</h1><blockquote>
<p>PaaS 是 <strong>P</strong>latform <strong>a</strong>s <strong>a</strong> <strong>S</strong>ervice 的缩写</p>
</blockquote>
<p>看到生意如此火爆，我也打算开个<em>熊小宇の咖啡店</em>。第一步是找铺面，一开始宣传资金和运营经验都是不够的，需要找一个相对成熟商场。而Shopping Mall的运营中心正有我所有需要的东西：</p>
<ul>
<li>出租繁华地段的铺面</li>
<li>合理的空间布局</li>
<li>相邻商铺间的内容互补分析</li>
<li>人流量与消费数据分析报告</li>
<li>饮品相关的品牌和供应渠道</li>
</ul>
<p>剩下要做的就是专注于设计自己的店铺，装修和请人干活了。购物中心先租赁或者购买物业的产权，进行品牌包装，整体设计和零售管理，来打造一个一站式的平台，形形色色的商家只要联系购物中心，缴纳租金和服务费就可以开店了。</p>
<p>云服务中<strong>PaaS</strong>这一层的就像是运营购物中心，<strong>PaaS</strong>提供给做<strong>SaaS</strong>服务的公司的一个基础平台，包括数据库、SDK、部署工具、控制台等等组件或框架，同时也提供行业解决方案与技术咨询&amp;支持。</p>
<p>如果你的需求只是一杯咖啡，你是不会去跟购物中心打交道的。购物中心面向客户仅是需要开店的商家。同样<strong>PaaS</strong>面向<strong>SaaS</strong>开发者的服务，而<strong>SaaS</strong>则是面向个人或者企业消费者的服务。</p>
<h2 id="角色扮演：-1"><a href="#角色扮演：-1" class="headerlink" title="角色扮演："></a>角色扮演：</h2><ul>
<li><strong>PaaS</strong> 提供商：购物中心运营商</li>
<li><strong>PaaS</strong> 消费者：咖啡店及各种商铺</li>
</ul>
<h1 id="IaaS：基础设施即服务-当个地产开发商"><a href="#IaaS：基础设施即服务-当个地产开发商" class="headerlink" title="IaaS：基础设施即服务 = 当个地产开发商"></a>IaaS：基础设施即服务 = 当个地产开发商</h1><blockquote>
<p>IaaS 是 <strong>I</strong>nfrastructure <strong>a</strong>s <strong>a</strong> <strong>S</strong>ervice 的缩写</p>
</blockquote>
<p>开了咖啡店又不满足了，我也希望能开一间小型的购物中心。了解过后知道一个购物中心也不都是从零开始打造的。首先会寻找一个繁华的地段、选择适合的场地建筑和基础设施，和开发商签约，再开始购物中心包装。而这么一个场地的建造则是由地产开发商完成的，包括：</p>
<ul>
<li>设计规划</li>
<li>建筑施工</li>
<li>水电安装</li>
<li>管道铺设</li>
</ul>
<p>整个工程工期漫长又耗资巨大，一般不是中小公司能玩转的。在基础设施建造完毕后，地产开发商再将毛坯物业出租或者出售给运营购物中心的企业，实现盈利。</p>
<p><strong>IaaS</strong>跟这地产商建房子相似，提供给消费者的服务是对所有计算基础设施的利用，包括处理CPU/GPU、存储、网络和其它基本的计算资源，以及运行环境所需的操作系统与虚拟化环境。同样重要的一点：<strong>IaaS</strong>的客户是<strong>PaaS</strong>服务商。</p>
<p>很多时候一些大的服务提供商同时会提供<strong>IaaS</strong>和<strong>PaaS</strong>的服务，比如阿里云和亚马逊AWS。这就像万达广场，除了整体的设计建造是万达集团的同时也自己的Shopping Mall品牌来运营购物中心。</p>
<h2 id="角色扮演：-2"><a href="#角色扮演：-2" class="headerlink" title="角色扮演："></a>角色扮演：</h2><ul>
<li><strong>IaaS</strong> 提供商：地产开发商</li>
<li><strong>IaaS</strong> 消费者：购物中心运营商</li>
</ul>
<h1 id="本地部署"><a href="#本地部署" class="headerlink" title="本地部署"></a>本地部署</h1><p>当然，我也可以自己从头开始打造一间咖啡店。买水泥、建房子、装水电、搞装修、买设备、进货、雇员工一切都自己来，这就是本地部署。不过算一笔账，开个咖啡店的成本本来只要二十万，时间一个月。但建房子成本需要一千万，时间两年，并且其中环节诸多，傻子才这么做啊。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/16/第二代蓝牙BLE SoC横向比较/" itemprop="url">
                  第二代蓝牙BLE SoC横向比较
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-12-16T18:31:35+08:00" content="2016-12-16">
              2016-12-16
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://oeti6csx6.bkt.clouddn.com/blog/20170206/183322058.jpg" alt=""></p>
<h1 id="BLE背景"><a href="#BLE背景" class="headerlink" title="BLE背景"></a>BLE背景</h1><p>从2010年7月Bluetooth SIG年发布蓝牙4.0 LE（Low Energy）低功耗版本蓝牙，到今天也才6个年头，而在iPhone和Android手机给力的支持下BLE得到了前所未有的快速普及。根据<a href="http://industryarc.com/Report/187/Bluetooth-smart-market-forcast.html" target="_blank" rel="external">市场调研报告</a>表明，到2020年，将会有84亿的设备通过BLE技术连接，市场符合增长率高达29%。<br>随着智能硬件和创客概念的迅猛发展，各种新概念的智能产品也层出不穷，BLE作为其中最为广泛应用的无线技术，成为了人和数字信息世界之间沟通的重要桥梁。这也是我们为什么要学习BLE的原因：只要你有好的idea，利用BLE技术可以迅速使你的idea和产品连接上智能手机和移动互联网的海量用户。</p>
<h1 id="第二代SoC"><a href="#第二代SoC" class="headerlink" title="第二代SoC"></a>第二代SoC</h1><p>回到产品，目前市面上常见的BLE SoC大体上可以分为两代，第一代是以TI、Nordic、CSR最早三家做BLE SOC的先驱者，经过几年的发展已经趋于成熟，价格也稳定在1美金以下，处于跑量的状态。第二代BLE SoC是在新的设计在制程更新到55nm后，功能性能功耗有着一次质的飞跃，除了之前几个老玩家以外，几家瞄准了IoT节点与Connectivity的MCU大厂也纷纷加入这场残酷战斗，增添了不少火药。</p>
<h1 id="入围名单"><a href="#入围名单" class="headerlink" title="入围名单"></a>入围名单</h1><ul>
<li><a href="http://www.nordicsemi.com/eng/Products/Bluetooth-low-energy/nRF52832" target="_blank" rel="external">nRF52832</a>（Noridc）（表示不服：我可是第三代都公布）</li>
<li><a href="http://www.dialog-semiconductor.com/products/connectivity/bluetooth-low-energy/smartbond-da14680" target="_blank" rel="external">DA14680</a>（Dialog）</li>
<li><a href="http://www.nxp.com/products/microcontrollers-and-processors/more-processors/application-specific-mcus-mpus/bluetooth-low-energy-ble/ultra-low-power-ble-system-on-chip-solution:QN9080?lang_cd=en" target="_blank" rel="external">QN9080</a>（NXP）（准备量产）</li>
<li><a href="http://www.ti.com.cn/product/cn/CC2640" target="_blank" rel="external">CC2640</a>（TI）</li>
<li><a href="http://www.cypress.com/products/psoc-4-ble-bluetooth-smart" target="_blank" rel="external">PSoC4 BLE</a>（Cypress）</li>
<li><a href="http://www.silabs.com/products/wireless/bluetooth/efr32-blue-gecko/Pages/blue-gecko-bluetooth-smart-soc.aspx" target="_blank" rel="external">EFR32BG1</a>（Silicon Labs）</li>
</ul>
<blockquote>
<p>其他几颗SoC如 CSR102x (CSR)，ATSAMB11（Microchip），TC35678（Toshiba）因资料不多或者或还未有成熟应用暂时没有放进来。</p>
</blockquote>
<h1 id="横向比较"><a href="#横向比较" class="headerlink" title="横向比较"></a>横向比较</h1><p><img src="http://oeti6csx6.bkt.clouddn.com/blog/20170206/183359333.png" alt=""></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul>
<li>最佳均衡奖：nRF52832 （最重要还是成熟）</li>
<li>最低功耗奖：QN9080 （新星，8MHz 跑协议栈, 3.4mA Tx @ 0dBm, 3.6mA Rx）</li>
<li>最佳射频奖：CC2640（-97dBm）</li>
<li>最大功率奖：EFR32BG1（+19.5dBm，好像蓝牙SIG只定义了10dBm…Orz）</li>
<li>最大容量奖：DA14680（1MB Flash）</li>
<li>最佳配角奖：PSoc4 BLE（路过… 非黑）</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/11/电容器与水桶的类比/" itemprop="url">
                  电容器与水桶的类比
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-11T18:39:10+08:00" content="2016-10-11">
              2016-10-11
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第一部分：电容器的电容C的【定义式】和【决定式】"><a href="#第一部分：电容器的电容C的【定义式】和【决定式】" class="headerlink" title="第一部分：电容器的电容C的【定义式】和【决定式】"></a>第一部分：电容器的电容C的【定义式】和【决定式】</h1><hr>
<h2 id="平行板电容器电容C的【定义式】"><a href="#平行板电容器电容C的【定义式】" class="headerlink" title="平行板电容器电容C的【定义式】"></a>平行板电容器电容C的【定义式】</h2><p>电容器所存储电荷量Q与两端电压U的比值为电容器的电容C，即 </p>
<blockquote>
<p>C = Q / U</p>
</blockquote>
<p>表示当存储1Q的电荷量时若电压为1V，那么电容为1F。</p>
<p>上述定义式仅表示在电路中量度该物理量的一种方法，我们不可以说”平行板电容器的电容C跟两板间所带的电荷量Q成正比，跟两板间的电压U成反比”。因为电容器的电容C是客观存在的，当两板不带电时，电容C依然存在。它的大小有【决定式】来决定。</p>
<h2 id="平行板电容器电容C的【决定式】"><a href="#平行板电容器电容C的【决定式】" class="headerlink" title="平行板电容器电容C的【决定式】"></a>平行板电容器电容C的【决定式】</h2><p>决定式就是表示该物理量的大小都与哪些因素有关系，通常是由其物理特性决定的，与所连接电路无关。对于电容器的电容C来说：</p>
<blockquote>
<p>C = εrS / 4πkd              </p>
</blockquote>
<p>其中k为静电力常量，库仑定律中的 k = 1 / (4πε0)，代入上面公式也可以得到更为简洁的公式：</p>
<blockquote>
<p>C = εrε0S / d</p>
</blockquote>
<p>ε0是真空介电常数，等于8.854187818 x 10-12 F/m<br>εr为平板电容器绝缘材料的相对介电常数，跟材料有关系，它没有量纲。εr越大，电容C越大<br>S为平行板正对面积。S越大，电容C越大<br>d为平行板之间的距离。d约大，电容C越小</p>
<h1 id="第二部分：电容器与水桶的类比"><a href="#第二部分：电容器与水桶的类比" class="headerlink" title="第二部分：电容器与水桶的类比"></a>第二部分：电容器与水桶的类比</h1><hr>
<p>电容器类比于水桶的概念，有助于快速理解电容器在电路中任一时刻电容C、电压U、电荷Q三者的关系。</p>
<p>根据电容器电容C的定义式得到：</p>
<blockquote>
<p>电荷Q = 电容C * 电压U</p>
</blockquote>
<p>对于水桶：</p>
<blockquote>
<p>水的体积V = 底面积S * 水面高度H</p>
</blockquote>
<p>我们可以做以下类比：</p>
<ul>
<li>电容C大小类比于水桶的底面积S（两者都是造出来以后就固定了）。</li>
<li>电容器两端的电压U类比于水面高度H（注意，是水面的高度，不是桶的高度，放水的多少不同，水面高度是有变化的）。</li>
<li>电容器存储的电荷Q类比于水桶内水的体积V。</li>
<li>电容器的极限耐压值Umax类比于水桶的高度Hmax。</li>
</ul>
<p>进一步来理解和验证以上的类比否合理：</p>
<ul>
<li>同样电荷Q向不同的电容器充电，电容C越大电容器，电压U越小。类比到水桶，同样体积的水V倒入不同的水桶里，底面积S越大的桶子，水面高度H越小。</li>
<li>某一电容器，当有更多的电荷Q注入，电压U就会越来越高，直到达到电容器的极限耐压值Umax。类比到水桶，某一水桶，只有更多体积的水V倒入，水面高度H就会不断上升，直到达到水桶的高度Hmax。</li>
<li><p>电容器可以容纳的最大电荷Qmax是指两端电压U达到极限耐压值时的值： Qmax = C * Umax<br>类比到水桶，一个水桶可以盛水的最大水的体积Vmax是指当水面高度H达到水桶高度时的值：Vmax= S * Hmax</p>
</li>
<li><p>平时我们说电容器充满了，是指在电容器两端的电压等于了外部电源电压，没有电势差之后，外部电源自然无法再向电容器充电。这时两者电压相同，C大的，所能存储的如果能进一步提高外部电压，电容器两端的电压U还可以继续升高直至极限耐压值Umax。类比到水桶，我们假设有两个水桶，两者底部是互通的。当水桶A（相当于电压源，也可以理解为电容器向电容器充电）的水面高度H比水桶B（相当于电容器）高时，水会从水桶A注入到水桶B中，直到两者的水面高度相同时停止。</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/10/FTF2016技术峰会上的可穿戴技术 - NFC支付手表/" itemprop="url">
                  FTF2016技术峰会上的可穿戴技术 - NFC支付手表
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-10T16:21:21+08:00" content="2016-10-10">
              2016-10-10
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h1><hr>
<p>飞亚达最新发布的<a href="http://epr.fiyta.com.cn:81/in-zn/index.html" target="_blank" rel="external">印系列智能手表</a>。不同于目前数字屏的显示方式，这款手表拥有传统的石英表外观和一个智能的机芯，让钟情传统手表的商务人士也能体验智能设备带来的便利。同样类似的产品我比较喜欢的是Withing的<a href="http://www.withings.com/us/en/products/activite-steel" target="_blank" rel="external">activite steel</a>，感觉Apple Watch瞬间被秒。<br><img src="http://oeti6csx6.bkt.clouddn.com//blog/2016-10-10/142446930" alt=""><br>除了配备基本的健康管理、消息提醒、防丢功能外，这款手表还提供30天的超长待机和NFC公交支付两大亮点。公交支付目前是非常火的移动应用，其使用率和用户粘性极高。</p>
<blockquote>
<p>9月1日小米发布的小米5 MiPay在手机端已经支持了北上广的公交卡应用</p>
</blockquote>
<p>飞亚达在手表端实现公交刷卡将绝对是更为友好的体验，目前功能还在测试中，据说10月底先会首先支持深圳通。在印系列手表上NFC公交支付与其他公交手环产品不同的是，据了解采用了与小米5采用了相同的全终端方案。可以通过空中发卡的方式来开通多个城市公交系统的支持，意味着用户去到不同的城市也可以非常方便的下载和使用当地城市的公交卡。</p>
<h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><hr>
<p>这款手表基于NXP支付手环参考设计方案，一个完整的硬件 + 软件可穿戴二次开发平台。其中包含了MCU、NFC前端与嵌入式Secure Element、蓝牙网络控制器以及加速度计等主要4颗芯片：</p>
<ul>
<li><a href="http://www.nxp.com/products/microcontrollers-and-processors/arm-processors/lpc-cortex-m-mcus/lpc-cortex-m4/lpc54000-low-power-cortex-m4/low-power-32-bit-microcontroller-mcu-based-on-arm-cortex-m4-core:LPC54102J512BD64?lang_cd=en" target="_blank" rel="external">LPC5410x</a> 低功耗微控制器</li>
<li>PN66T NFC前端控制器与嵌入式Secure Element</li>
<li><a href="http://www.nxp.com/products/microcontrollers-and-processors/more-processors/application-specific-mcus-mpus/bluetooth-low-energy-ble/ultra-low-power-bluetooth-le-system-on-chip-solution:QN9020?fsrch=1&amp;sr=1&amp;pageNum=1" target="_blank" rel="external">QN902x</a> 低功耗蓝牙SoC</li>
<li><a href="http://www.nxp.com/products/sensors/accelerometers/3-axis-accelerometers/2g-4g-8g-low-g-12-bit-digital-accelerometer:MMA8652FC?lang_cd=en" target="_blank" rel="external">MMA8652</a> 低功耗加速度计</li>
</ul>
<p>系统框图如下：<br><img src="http://oeti6csx6.bkt.clouddn.com//blog/2016-10-10/143514127" alt=""><br>在参考设计方案中，除了线路设计图还包含有完整的SDK软件开发套件。NXP可穿戴支付SDK包含了一个由FreeRTOS实时内核调度的NFC中间件和抽象的SE API应用编程接口，NFC业务开发可以直接通过SE API提供的接口进行而无需关心底层是如何沟通的，同时这组接口还扩展了LoaderService与MiFare Open Platform的功能。</p>
<blockquote>
<p>Loader Service 使服务提供商可以简化NFC安全应用的部署，具体可参考NXP官网的一篇白皮书<a href="http://cache.nxp.com/files/nxp/brochure/WHITEPAPER-PAYMENT.pdf" target="_blank" rel="external">Loader Service: The Tipping Point for Secure NFC Payments</a></p>
</blockquote>
<p>除了NFC和SE管理中间件，在SDK中还提供了多个系统组件以满足通用可穿戴设备Time to Market的要求：</p>
<ul>
<li>LPCXpresso驱动库</li>
<li>低功耗管理API和FreeRTOS tickless模式</li>
<li>计步器算法</li>
<li>ANCS蓝牙Profile</li>
<li>OTA 空中升级</li>
<li>参考Android APP</li>
</ul>
<p>低功耗是可穿戴设备的一个重要指标，采用这个方案的系统待机功耗小于100uA，在典型工作场景下150mA电池可以使用一个月。</p>
<table>
<thead>
<tr>
<th style="text-align:left">芯片</th>
<th style="text-align:left">功耗</th>
<th style="text-align:left">备注 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">LPC54101</td>
<td style="text-align:left">~25uA</td>
<td style="text-align:left">Power down模式 + RTC + 看门狗定时器</td>
</tr>
<tr>
<td style="text-align:left">QN9022</td>
<td style="text-align:left">~25uA</td>
<td style="text-align:left">可被发现，1秒慢广播</td>
</tr>
<tr>
<td style="text-align:left">PN66T</td>
<td style="text-align:left">~20uA</td>
<td style="text-align:left">Standby模式, RF场唤醒</td>
</tr>
<tr>
<td style="text-align:left">MMA8652</td>
<td style="text-align:left">~2uA</td>
<td style="text-align:left">Standby模式</td>
</tr>
</tbody>
</table>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr>
<p>这两年可穿戴产品炒得太过火热，行业新增概念和亮点并不多，特别是手环类的产品，除了时间管理、消息通知、健康运动和位置追踪几个主打应用，能真正解决用户痛点的应用少之又少。今年行业领跑者估值大幅度缩水，Jawbone甚至跌回了5年前水平，几大品牌在小米和其他国产手环产品的低价策略冲击下处境艰难。设备制造商在这样的竞争环境下必须不断创新，找准出路。NFC可穿戴是一个不错的技术路线，同时市场也日渐成熟。</p>
<p>总结NFC移动支付和公交应用带来的改变：</p>
<ul>
<li>服务提供商吸引客户通过手机和可穿戴设备进行业务操作，提升应用体验、增加用户粘度。</li>
<li>软硬件设备制造商依托于服务器提供商的平台，迅速提高产品销量和提升毛利率。</li>
<li>终端用户则简化了安全支付，公交充值，卡管理等等日常低效繁杂操作</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/10/FTF2016技术峰会上的可穿戴技术 - HexiWear/" itemprop="url">
                  FTF2016技术峰会上的可穿戴技术 - HexiWear
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-10T16:20:21+08:00" content="2016-10-10">
              2016-10-10
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HexiWear可穿戴技术原型开发平台"><a href="#HexiWear可穿戴技术原型开发平台" class="headerlink" title="HexiWear可穿戴技术原型开发平台"></a>HexiWear可穿戴技术原型开发平台</h1><hr>
<p><img src="http://oeti6csx6.bkt.clouddn.com//blog/2016-10-10/144709502" alt=""><br><a href="http://www.hexiwear.com/" target="_blank" rel="external">HexiWear</a>是由<a href="http://www.mikroe.com/" target="_blank" rel="external">mikroelektronika</a>与<a href="http://www.nxp.com/" target="_blank" rel="external">NXP</a>一起开发的基于MCU的开源IoT与可穿戴原型开发。所有资料包括原理图、PCB设计文件、固件以及App的源码都可以从HexiWear网站或者<a href="https://github.com/MikroElektronika/HEXIWEAR/" target="_blank" rel="external">Github</a>获取。<br><img src="http://oeti6csx6.bkt.clouddn.com/blog/20170206/182849190.png" alt=""></p>
<blockquote>
<p><strong>NOTE</strong>: 其中固件的框架和GUI，计步器库等内容值得学习以用于进行二次开发</p>
</blockquote>
<p>从系统框图来看，在这个小小的手表空间里包含了7颗NXP芯片，涵盖了MCU主控、BLE无线连接、9轴运动传感器、压力传感器和电源管理功能，除此之外还支持温湿度、环境光传感器和心率传感器。反正能找的传感器都已经支持了，如果能加上GPS就完美了。在印象中也就是Microsoft Band 2（主控似乎是Kinetis K26）有这么多Sensor了。</p>
<ul>
<li><a href="http://www.nxp.com/zh-Hans/products/microcontrollers-and-processors/arm-processors/kinetis-cortex-m-mcus/k-series-performance-m4/k6x-ethernet/kinetis-k64-120-mhz-256kb-sram-microcontrollers-mcus-based-on-arm-cortex-m4-core:K64_120" target="_blank" rel="external">Kinetis K64F</a>微控制器（主控）</li>
<li><a href="http://www.nxp.com/zh-Hans/products/microcontrollers-and-processors/arm-processors/kinetis-cortex-m-mcus/w-series-wireless-m0-plus-m4/kinetis-kw40z-2.4-ghz-dual-mode-ble-and-802.15.4-wireless-radio-microcontroller-mcu-based-on-arm-cortex-m0-plus-core:KW40Z" target="_blank" rel="external">Kinetis KW40Z</a>单芯片BLE与802.15.4多协议无线处理器</li>
<li><a href="http://www.nxp.com/products/sensors/6-axis-sensors/digital-sensor-3d-accelerometer-2g-4g-8g-plus-3d-magnetometer:FXOS8700CQ?lang_cd=zh-Hans" target="_blank" rel="external">FXOS8700CQ</a>六轴加速度与地磁传感器</li>
<li><a href="http://www.nxp.com/products/sensors/gyroscopes/3-axis-digital-gyroscope:FXAS21002C?lang_cd=zh-Hans" target="_blank" rel="external">FXAS21002</a>三轴角速度传感器（陀螺仪）</li>
<li><a href="http://www.nxp.com/products/sensors/pressure-sensors/barometric-pressure-15-to-115-kpa/20-to-110kpa-absolute-digital-pressure-sensor:MPL3115A2?lang_cd=zh-Hans" target="_blank" rel="external">MPL3115A2</a>绝对压力传感器</li>
<li><a href="http://www.nxp.com/products/power-management/battery-management/battery-chargers/600-ma-single-cell-li-ion-li-polymer-battery-charger:MC34671?lang_cd=zh-Hans" target="_blank" rel="external">MC34671</a>单节锂电池充电管理器</li>
<li>Kinetis K20<a href="http://www.nxp.com/products/software-and-tools/run-time-software/kinetis-software-and-tools/ides-for-kinetis-mcus/opensda-serial-and-debug-adapter:OPENSDA" target="_blank" rel="external">OpenSDA调试器</a><br><img src="http://oeti6csx6.bkt.clouddn.com//blog/2016-10-10/144958509" alt=""></li>
</ul>
<p>在我看来这个平台最能吸引开发者的是HexiWear能通过Docking板来扩展mikroelektronika提供的上百种<a href="http://www.mikroe.com/click" target="_blank" rel="external">click</a>物联网模块，可用最快的速度进行原型的开发与验证。(mikroelektronika我真是服，编译器，软件，硬件模块什么都能造）<br><img src="http://oeti6csx6.bkt.clouddn.com//blog/2016-10-10/145411896" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/10/FTF2016技术峰会上的可穿戴技术 - NFMI/" itemprop="url">
                  FTF2016技术峰会上的可穿戴技术 - NFMI无线耳塞
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-10T16:11:24+08:00" content="2016-10-10">
              2016-10-10
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="市场"><a href="#市场" class="headerlink" title="市场"></a>市场</h1><hr>
<p>Hearable属于Wearable可穿戴的一个分支。每年都有数以千万的耳塞、耳机被销售和使用。相比手腕位置，用户群体更广，在耳机产品平台上发展智能技术越来越受到重视。下面来看看由一根线引发革命：真无线耳塞</p>
<p>尽管Apple近年来一直在控制创新风险，做出的产品对于市场还是有极强的冲击力。这次随着iPhone7出来的AirPods让双耳无线耳塞产品火（吐槽）了一把。同类产品早在两年前就有不少的创业型公司已经有开始众筹，相信在AirPods的刺激下整个市场在今年下半年和明年会有一个爆发期。目前ifixit和Chipworks还看不到拆解分析，需要了解AirPods的小伙伴可以看看这篇YY分析：<a href="https://www.linkedin.com/pulse/airpods-speculative-teardown-nick-hunn" target="_blank" rel="external">AirPods - a Speculative Teardown</a>。<br><img src="http://oeti6csx6.bkt.clouddn.com//blog/2016-10-10/145538557" alt=""><br>在FTF上NXP展出的双耳无线耳塞技术基于NFMI的方案，这个技术算是NXP的独门绝技了。NFMI技术早在10年前就已经被采用在助听器技术中，用于提供两耳之间超低功耗的语音传输。NXP将这个技术进行的升级优化，提高了带宽以用于消费级的无线音乐传输目的，之前KickStart上非常火的无线耳机<a href="http://www.bragi.com/thedash/" target="_blank" rel="external">the dash</a>就使用了NXP第一代的NFMI芯片，本次展出的是第二代NFMI芯片<a href="http://www.nxp.com/products/interface-and-connectivity/wireless-connectivity/nfmi-radio-solutions/nfmi-radio-for-wireless-audio-and-data-streaming:NXH2280UK?lang_cd=en" target="_blank" rel="external">NXH2280</a>。其他基于NFMI技术的耳机还有</p>
<ul>
<li><a href="http://www.bragi.com/theheadphone/" target="_blank" rel="external">the headphone</a> from Bragi</li>
<li><a href="http://www.jabra.com/sports-headphones/jabra-elite-sport" target="_blank" rel="external">Elite Sport</a> from Jabra</li>
</ul>
<blockquote>
<p>NFMI = <strong>N</strong>ear <strong>F</strong>ield <strong>M</strong>agnetic <strong>I</strong>nductive = 近场无线磁传导</p>
</blockquote>
<h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><hr>
<p>NFMI为什么在这个市场上占有一席之地需要从需求谈起。目前市面上的普通无线耳塞技术都是基于蓝牙Classic的A2DP协议，而A2DP协议本身设计是点对点传输音频数据，当用户希望两个耳朵完全没有线缆时这个技术在实现上需要做一些修改，最为常见的是CSR提供的中继方案：一个耳塞收到A2DP的立体声audio之后，本地分离出左右声道再次通过蓝牙传输到另外一个耳塞，同时做同步控制。早期的无线耳塞<a href="https://www.earin.com/" target="_blank" rel="external">Earin</a>就是使用的这个技术。它最大的问题是人体皮肤对于2.4G信号的吸收，导致其无线设计非常具有挑战，特别当耳机体积做的很小的时候几乎无法解决两耳之间音频传输的稳定性。而NFMI技术的出现解决了这个问题，对于人体免疫的特性让他非常适合作音频中继的用途。这次摆在展台的是NXP开发的基于NXH2280的ADK，系统组成近似于：<br><img src="http://oeti6csx6.bkt.clouddn.com//blog/2016-10-10/150125092" alt=""></p>
<blockquote>
<p>ADK = <strong>A</strong>pplication <strong>D</strong>evelopment <strong>K</strong>it = 应用开发套件</p>
</blockquote>
<p>大致的工作流程：从手机蓝牙通过A2DP协议将经过SBC，AAC或者aptX压缩的双声道音频传输到其中一个耳塞中的蓝牙SOC，经过解码后将两个声道分离，本地的通道经过一定的延时（等同于无线）后播放出来，对端的声道发送给本地NXH2280进行压缩后和传输， 在另外一只耳塞的NXH2280收到音频数据包进行解压缩、重采样、延时控制后输出给CODEC进行播放。</p>
<p>需要注意的是虽然NXH2280主要的市场是无线音频，但也可以用于其他需要超低功耗和近距离通讯，特别是紧贴人体的传感器应用场景，比如标贴医疗传感器，体内药丸等，全靠脑洞大开的电子工程小伙伴们开发新的想法了。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr>
<p>最后总结一下NFMI技术的几个技术特点和限制：</p>
<ol>
<li>超低功耗（传输经过压缩的48kHz单声道音频小于2mA）</li>
<li>免疫皮肤组织</li>
<li>可以在水下工作（游泳也可以听歌哦）</li>
<li>与其他无线技术的共存和兼容性</li>
<li>天然的安全性</li>
<li>在小天线和低功场景下，通讯距离短（&lt;50cm）</li>
<li>吞吐率较低（596kbps）</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Neo Xiong" />
          <p class="site-author-name" itemprop="name">Neo Xiong</p>
          <p class="site-description motion-element" itemprop="description">测试</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">8</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Neo Xiong</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
